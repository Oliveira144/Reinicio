import streamlit as st
from collections import deque, Counter
from typing import List, Tuple, Optional, Dict
import re
import numpy as np
from datetime import datetime

# ==============================
# Configura√ß√µes e constantes
# ==============================
MAX_HISTORY = 30
STREAK_LENGTHS = [2, 3, 4, 5, 6]
PATTERN_SIZES = [2, 3, 4, 5, 6]
CYCLE_SIZES = [2, 3, 4, 5]

# ==============================
# Classe principal de an√°lise din√¢mica
# ==============================
class FootballStudioAnalyzer:
    def __init__(self):
        self.pattern_weights = {
            'high_streak': 5,          # Streaks longos
            'medium_streak': 3,        # Streaks m√©dios
            'low_streak': 2,           # Streaks curtos
            'repetition': 4,           # Padr√µes repetidos
            'alternation': 3,          # Padr√µes de altern√¢ncia
            'cycle': 4,                # Ciclos
            'mirror': 4,               # Padr√µes espelhados
            'draw_pattern': 3,         # Padr√µes com empates
            'statistical': 5,          # An√°lise estat√≠stica
            'cluster': 3,              # Agrupamentos
            'zebra': 3,                # Padr√£o zebra
            'reversal': 3              # Revers√µes
        }
        
    def get_opposite_color(self, color: str) -> str:
        """Retorna a cor oposta para sugest√£o de apostas"""
        if color == "üî¥": return "üîµ"
        elif color == "üîµ": return "üî¥"
        return "üü°"
    
    def detect_all_patterns(self, history: List[str]) -> Tuple[List[Dict], Dict]:
        """Detecta todos os padr√µes poss√≠veis no hist√≥rico"""
        if len(history) < 5:
            return [], {}
            
        patterns = []
        confidence_scores = {"üî¥": 0, "üîµ": 0, "üü°": 0}
        
        # 1. An√°lise de streaks (sequ√™ncias)
        streaks = self._analyze_streaks(history)
        patterns.extend(streaks)
        
        # 2. An√°lise de padr√µes repetitivos
        repetitions = self._analyze_repetitions(history)
        patterns.extend(repetitions)
        
        # 3. An√°lise de ciclos
        cycles = self._analyze_cycles(history)
        patterns.extend(cycles)
        
        # 4. An√°lise de padr√µes com empates
        draw_patterns = self._analyze_draw_patterns(history)
        patterns.extend(draw_patterns)
        
        # 5. An√°lise estat√≠stica
        stats_patterns = self._analyze_statistical(history)
        patterns.extend(stats_patterns)
        
        # 6. An√°lise de agrupamentos
        clusters = self._analyze_clusters(history)
        patterns.extend(clusters)
        
        # 7. An√°lise de padr√µes avan√ßados
        advanced = self._analyze_advanced_patterns(history)
        patterns.extend(advanced)
        
        # Calcular pontua√ß√£o de confian√ßa para cada cor
        for pattern in patterns:
            if pattern['suggestion'] in confidence_scores:
                confidence_scores[pattern['suggestion']] += pattern['confidence']
        
        return patterns, confidence_scores
    
    def _analyze_streaks(self, history: List[str]) -> List[Dict]:
        """Analisa sequ√™ncias de cores iguais"""
        patterns = []
        recent = history[-10:]  # √öltimas 10 jogadas
        
        for length in STREAK_LENGTHS:
            if len(recent) < length:
                continue
                
            # Verificar streaks de vermelho
            if all(c == "üî¥" for c in recent[-length:]):
                confidence = self.pattern_weights['high_streak'] if length >= 4 else self.pattern_weights['medium_streak']
                patterns.append({
                    'type': f'streak_red_{length}',
                    'description': f'Sequ√™ncia de {length} vermelhos consecutivos',
                    'suggestion': 'üîµ',
                    'confidence': confidence
                })
            
            # Verificar streaks de azul
            if all(c == "üîµ" for c in recent[-length:]):
                confidence = self.pattern_weights['high_streak'] if length >= 4 else self.pattern_weights['medium_streak']
                patterns.append({
                    'type': f'streak_blue_{length}',
                    'description': f'Sequ√™ncia de {length} azuis consecutivos',
                    'suggestion': 'üî¥',
                    'confidence': confidence
                })
        
        return patterns
    
    def _analyze_repetitions(self, history: List[str]) -> List[Dict]:
        """Analisa padr√µes repetitivos"""
        patterns = []
        recent = history[-12:]  # √öltimas 12 jogadas
        
        for size in PATTERN_SIZES:
            if len(recent) < size * 2:
                continue
                
            # Verificar padr√µes repetidos (ex: üî¥üîµüî¥üîµ se repete)
            first = recent[-(size*2):-size]
            second = recent[-size:]
            
            if first == second:
                # Determinar pr√≥xima cor baseada no padr√£o
                next_index = size % len(first)
                next_color = first[next_index] if first[next_index] != "üü°" else first[0]
                
                patterns.append({
                    'type': f'repetition_{size}',
                    'description': f'Padr√£o de {size} cores se repetindo',
                    'suggestion': next_color,
                    'confidence': self.pattern_weights['repetition']
                })
        
        return patterns
    
    def _analyze_cycles(self, history: List[str]) -> List[Dict]:
        """Analisa padr√µes c√≠clicos"""
        patterns = []
        recent = history[-12:]
        
        for size in CYCLE_SIZES:
            if len(recent) < size * 2:
                continue
                
            # Verificar ciclos regulares
            first = recent[-(size*2):-size]
            second = recent[-size:]
            
            if first == second:
                next_color = first[0] if first[0] != "üü°" else first[1]
                patterns.append({
                    'type': f'cycle_regular_{size}',
                    'description': f'Ciclo regular de {size} cores',
                    'suggestion': next_color,
                    'confidence': self.pattern_weights['cycle']
                })
            
            # Verificar ciclos invertidos
            if first == list(reversed(second)):
                next_color = self.get_opposite_color(second[-1]) if second[-1] != "üü°" else "üî¥"
                patterns.append({
                    'type': f'cycle_inverted_{size}',
                    'description': f'Ciclo invertido de {size} cores',
                    'suggestion': next_color,
                    'confidence': self.pattern_weights['cycle']
                })
        
        return patterns
    
    def _analyze_draw_patterns(self, history: List[str]) -> List[Dict]:
        """Analisa padr√µes envolvendo empates"""
        patterns = []
        recent = history[-8:]
        draw_positions = [i for i, c in enumerate(recent) if c == "üü°"]
        
        if not draw_positions:
            return patterns
        
        # Padr√£o: Empate seguido de tend√™ncia
        if len(recent) >= 3 and recent[-2] == "üü°" and recent[-1] != "üü°":
            patterns.append({
                'type': 'draw_followed',
                'description': 'Empate seguido de cor definida',
                'suggestion': recent[-1],
                'confidence': self.pattern_weights['draw_pattern']
            })
        
        # Padr√£o: M√∫ltiplos empates pr√≥ximos
        if len(draw_positions) >= 2:
            last_draw_gap = draw_positions[-1] - draw_positions[-2]
            if last_draw_gap <= 2:  # Empates muito pr√≥ximos
                patterns.append({
                    'type': 'draw_cluster',
                    'description': 'Agrupamento de empates recentes',
                    'suggestion': self.get_opposite_color(history[-1]) if history[-1] != "üü°" else "üî¥",
                    'confidence': self.pattern_weights['draw_pattern']
                })
        
        return patterns
    
    def _analyze_statistical(self, history: List[str]) -> List[Dict]:
        """An√°lise estat√≠stica do hist√≥rico"""
        patterns = []
        recent = history[-15:]
        
        if len(recent) < 10:
            return patterns
        
        red_count = recent.count("üî¥")
        blue_count = recent.count("üîµ")
        total = red_count + blue_count
        
        if total == 0:
            return patterns
        
        # Desequil√≠brio significativo
        if red_count / total >= 0.7:
            patterns.append({
                'type': 'statistical_imbalance_red',
                'description': f'Desequil√≠brio estat√≠stico: {red_count}üî¥ vs {blue_count}üîµ',
                'suggestion': 'üîµ',
                'confidence': self.pattern_weights['statistical']
            })
        elif blue_count / total >= 0.7:
            patterns.append({
                'type': 'statistical_imbalance_blue',
                'description': f'Desequil√≠brio estat√≠stico: {blue_count}üîµ vs {red_count}üî¥',
                'suggestion': 'üî¥',
                'confidence': self.pattern_weights['statistical']
            })
        
        # Tend√™ncia recente (√∫ltimas 5 vs anteriores)
        if len(recent) >= 10:
            last_5 = recent[-5:]
            previous_5 = recent[-10:-5]
            
            last_red = last_5.count("üî¥")
            last_blue = last_5.count("üîµ")
            prev_red = previous_5.count("üî¥")
            prev_blue = previous_5.count("üîµ")
            
            # Mudan√ßa significativa de tend√™ncia
            if last_red >= 4 and prev_blue >= 3:
                patterns.append({
                    'type': 'trend_change_red',
                    'description': 'Mudan√ßa de tend√™ncia para vermelho',
                    'suggestion': 'üî¥',
                    'confidence': self.pattern_weights['statistical']
                })
            elif last_blue >= 4 and prev_red >= 3:
                patterns.append({
                    'type': 'trend_change_blue',
                    'description': 'Mudan√ßa de tend√™ncia para azul',
                    'suggestion': 'üîµ',
                    'confidence': self.pattern_weights['statistical']
                })
        
        return patterns
    
    def _analyze_clusters(self, history: List[str]) -> List[Dict]:
        """Analisa agrupamentos de cores"""
        patterns = []
        recent = history[-10:]
        
        # Verificar agrupamentos extremos
        for color in ["üî¥", "üîµ"]:
            count = recent.count(color)
            if count >= 7:  # 70% ou mais de uma cor
                patterns.append({
                    'type': f'cluster_{color}',
                    'description': f'Agrupamento extremo de {color}',
                    'suggestion': self.get_opposite_color(color),
                    'confidence': self.pattern_weights['cluster']
                })
        
        return patterns
    
    def _analyze_advanced_patterns(self, history: List[str]) -> List[Dict]:
        """Analisa padr√µes avan√ßados e complexos"""
        patterns = []
        recent = history[-12:]
        
        # Padr√£o Zebra (altern√¢ncia perfeita)
        zebra = True
        for i in range(1, len(recent)):
            if recent[i] == recent[i-1] or recent[i] == "üü°" or recent[i-1] == "üü°":
                zebra = False
                break
                
        if zebra and len(recent) >= 4:
            patterns.append({
                'type': 'zebra_pattern',
                'description': 'Padr√£o zebra (altern√¢ncia perfeita)',
                'suggestion': recent[-2],  # Manter a altern√¢ncia
                'confidence': self.pattern_weights['zebra']
            })
        
        # Padr√£o de revers√£o (ex: üî¥üî¥üîµ -> continua üîµ)
        if len(recent) >= 4:
            if recent[-3] == recent[-2] and recent[-2] != recent[-1] and recent[-1] != "üü°":
                patterns.append({
                    'type': 'reversal_pattern',
                    'description': 'Padr√£o de revers√£o ap√≥s sequ√™ncia',
                    'suggestion': recent[-1],  # Continuar a revers√£o
                    'confidence': self.pattern_weights['reversal']
                })
        
        return patterns
    
    def generate_recommendation(self, confidence_scores: Dict) -> Tuple[str, float]:
        """Gera recomenda√ß√£o baseada nas pontua√ß√µes de confian√ßa"""
        if not confidence_scores or sum(confidence_scores.values()) == 0:
            return "Aguardar", 0.0
        
        max_score = max(confidence_scores.values())
        total_score = sum(confidence_scores.values())
        
        if max_score == 0:
            return "Aguardar", 0.0
        
        # Encontrar a cor com maior pontua√ß√£o
        for color, score in confidence_scores.items():
            if score == max_score:
                confidence_percentage = (max_score / total_score) * 100
                return color, confidence_percentage
        
        return "Aguardar", 0.0

# ==============================
# Interface Streamlit melhorada
# ==============================
def main():
    st.set_page_config(
        page_title="Football Studio Analyzer Pro", 
        layout="wide",
        page_icon="üé≤"
    )
    
    st.title("üé≤ Football Studio Analyzer Pro")
    st.write("Sistema avan√ßado de an√°lise de padr√µes em tempo real para Football Studio")
    
    # Inicializar analisador
    if "analyzer" not in st.session_state:
        st.session_state.analyzer = FootballStudioAnalyzer()
    
    # Inicializar hist√≥rico
    if "history" not in st.session_state:
        st.session_state.history = deque(maxlen=MAX_HISTORY)
    
    # Inicializar estat√≠sticas
    if "pattern_stats" not in st.session_state:
        st.session_state.pattern_stats = {
            "üî¥": 0, "üîµ": 0, "üü°": 0,
            "total_analyzed": 0,
            "last_analysis": None
        }
    
    # Sidebar para controles
    with st.sidebar:
        st.header("‚öôÔ∏è Controles")
        
        # Entrada r√°pida de resultados
        st.subheader("Entrada R√°pida")
        sequence_input = st.text_input("Digite uma sequ√™ncia (ex: üî¥üîµüü°üî¥):", "")
        if st.button("Adicionar Sequ√™ncia") and sequence_input:
            # Extrair emojis v√°lidos
            emojis = re.findall(r'[üî¥üîµüü°]', sequence_input)
            for emoji in emojis:
                st.session_state.history.append(emoji)
            st.success(f"{len(emojis)} resultados adicionados!")
            st.rerun()
        
        # Controles de hist√≥rico
        st.subheader("Gerenciamento de Hist√≥rico")
        if st.button("üóëÔ∏è Limpar Hist√≥rico", type="secondary"):
            st.session_state.history.clear()
            st.success("Hist√≥rico limpo!")
            st.rerun()
            
        if st.button("‚Ü©Ô∏è Desfazer √öltimo", type="secondary") and st.session_state.history:
            st.session_state.history.pop()
            st.success("√öltimo resultado removido!")
            st.rerun()
        
        # Configura√ß√µes de an√°lise
        st.subheader("Configura√ß√µes de An√°lise")
        analysis_depth = st.slider("Profundidade de An√°lise", 5, 30, 15, 
                                  help="Quantidade de jogadas anteriores a serem analisadas")
    
    # Layout principal
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.subheader("üéØ Registrar Resultado")
        
        # Bot√µes de entrada
        btn_col1, btn_col2, btn_col3 = st.columns(3)
        with btn_col1:
            if st.button("üî¥", use_container_width=True, key="red_btn"):
                st.session_state.history.append("üî¥")
                st.rerun()
        with btn_col2:
            if st.button("üîµ", use_container_width=True, key="blue_btn"):
                st.session_state.history.append("üîµ")
                st.rerun()
        with btn_col3:
            if st.button("üü°", use_container_width=True, key="draw_btn"):
                st.session_state.history.append("üü°")
                st.rerun()
        
        # Exibir hist√≥rico
        st.subheader("üìú Hist√≥rico Recente")
        if st.session_state.history:
            # Mostrar hist√≥rico com os mais recentes primeiro
            reversed_history = list(reversed(st.session_state.history))
            cols = st.columns(min(10, len(reversed_history)))
            for idx, result in enumerate(reversed_history):
                with cols[idx % len(cols)]:
                    st.markdown(f"<h3 style='text-align: center;'>{result}</h3>", 
                               unsafe_allow_html=True)
        else:
            st.info("Nenhum resultado registrado ainda.")
        
        # Estat√≠sticas simples
        if st.session_state.history:
            st.subheader("üìä Estat√≠sticas B√°sicas")
            red_count = list(st.session_state.history).count("üî¥")
            blue_count = list(st.session_state.history).count("üîµ")
            draw_count = list(st.session_state.history).count("üü°")
            total = len(st.session_state.history)
            
            col_stat1, col_stat2, col_stat3 = st.columns(3)
            with col_stat1:
                st.metric("üî¥ Vermelho", f"{red_count} ({red_count/total*100:.1f}%)")
            with col_stat2:
                st.metric("üîµ Azul", f"{blue_count} ({blue_count/total*100:.1f}%)")
            with col_stat3:
                st.metric("üü° Empate", f"{draw_count} ({draw_count/total*100:.1f}%)")
    
    with col2:
        st.subheader("ü§ñ An√°lise de Padr√µes em Tempo Real")
        
        if len(st.session_state.history) >= 5:
            # Realizar an√°lise
            patterns, confidence_scores = st.session_state.analyzer.detect_all_patterns(
                list(st.session_state.history)[-analysis_depth:]
            )
            
            # Gerar recomenda√ß√£o
            recommendation, confidence = st.session_state.analyzer.generate_recommendation(confidence_scores)
            
            # Exibir recomenda√ß√£o principal
            st.subheader("üí° Recomenda√ß√£o de Entrada")
            
            # Destacar a recomenda√ß√£o com base na confian√ßa
            if confidence > 60:
                st.success(f"## {recommendation} (Confian√ßa: {confidence:.1f}%)")
                st.write("**Alta confian√ßa nesta recomenda√ß√£o**")
            elif confidence > 30:
                st.info(f"## {recommendation} (Confian√ßa: {confidence:.1f}%)")
                st.write("**Confian√ßa moderada nesta recomenda√ß√£o**")
            else:
                st.warning(f"## {recommendation} (Confian√ßa: {confidence:.1f}%)")
                st.write("**Baixa confian√ßa - aguardar padr√£o mais claro**")
            
            # Exibir padr√µes detectados
            st.subheader("üîç Padr√µes Detectados")
            if patterns:
                # Agrupar padr√µes por tipo
                pattern_categories = {}
                for pattern in patterns:
                    category = pattern['type'].split('_')[0]
                    if category not in pattern_categories:
                        pattern_categories[category] = []
                    pattern_categories[category].append(pattern)
                
                # Exibir padr√µes por categoria
                for category, items in pattern_categories.items():
                    with st.expander(f"{category.title()} ({len(items)} padr√µes)"):
                        for pattern in items:
                            st.write(f"**{pattern['description']}**")
                            st.write(f"Sugest√£o: {pattern['suggestion']} | Confian√ßa: {pattern['confidence']}")
            else:
                st.info("Nenhum padr√£o significativo detectado. Continue registrando resultados.")
            
            # Exibir pontua√ß√µes de confian√ßa
            st.subheader("üìà Pontua√ß√µes de Confian√ßa")
            col_conf1, col_conf2, col_conf3 = st.columns(3)
            with col_conf1:
                st.metric("üî¥ Vermelho", f"{confidence_scores.get('üî¥', 0):.1f}")
            with col_conf2:
                st.metric("üîµ Azul", f"{confidence_scores.get('üîµ', 0):.1f}")
            with col_conf3:
                st.metric("üü° Empate", f"{confidence_scores.get('üü°', 0):.1f}")
        
        else:
            st.info("Registre pelo menos 5 resultados para ativar a an√°lise de padr√µes.")
    
    # Rodap√© com informa√ß√µes adicionais
    st.divider()
    st.write("""
    **Sobre o sistema:** Este analisador verifica mais de 40 padr√µes diferentes em tempo real, 
    adaptando-se dinamicamente ao hist√≥rico de resultados. Quanto mais dados dispon√≠veis, 
    mais precisas se tornam as recomenda√ß√µes.
    """)

if __name__ == "__main__":
    main()
